\section{On-chain Protocol}\label{sec:on-chain}

\todo{Problem: Always ensure abort is possible. E.g. by individual aborts!?}

We describe the details of the \emph{on-chain} protocol controlling a
Hydra head (see Fig.~\ref{fig:SM_states_basic}) using the CEM abstraction \&
notation (see Section~\ref{sec:cem}). In addition of standard CEM modeling, we
also provide the formal conditions $\cemTxCon$ which a transition need to
satisfy and also include them in the accompanying text.

The following sections describe the structure of each of the transactions
comprising the Head protocol: $\mtxInit{}$, $\mtxCom{}$, $\mtxAbort{}$,
$\mtxCollect{}$, $\mtxClose{}$, $\mtxContest{}$, and $\mtxFanout{}$. Following
the EUTxO model, this structure is enforced on-chain through \emph{validators}
which are \emph{scripts instances} attached to each UTxO and run as part of the
ledger's validation of the transaction (see Section~\ref{sec:eutxo}). The
protocol defines one minting policy script and three validator scripts:
\begin{itemize}
  \item $\muHead$ governs the minting of state and participation tokens,
  \item $\nuInitial$ controls initialization and how UTxOs are committed to the head, while
  \item $\nuCommit$ controls the collection of committed UTxOs into the head, and lastly
  \item $\nuHead$ controls the main protocol state-machine logic.
\end{itemize}

\subsection{Init transaction}\label{sec:init-tx}

The \mtxInit{} transaction creates a head instance and establishes the initial
state of the protocol and is shown in Figure~\ref{fig:SM_commit_tx}. The head
instance is represented by the unique\footnote{As the EUTxO ledger preventing
  double-spending, the uniqueness of $\cid$ is guaranteed because $i_{seed}$ can
  only be spent once} currency identifier $\cid$ created by minting tokens using
the parameterized $\muHead$ minting policy script:
\[
  \cid = \hash(\muHead(i_{seed}))
\]
\noindent where $i_{seed} \in \txInputs$ is a transaction input and the
$\muHead(i_{seed})$ minting policy validator checks:
\begin{menumerate}
  \item When minting at least one token of this policy
  $\exists \{\cid \mapsto \cdot \mapsto q\} \in \txMint : q > 0$\todo{value
    notation}, $i_{seed}$ needs to be spent in this transaction
  $i_{seed} \in \txInputs$.
\end{menumerate}

\vspace{0.1cm}
\noindent Two kinds of tokens are minted:
\begin{itemize}
  \item A single \emph{State Thread (ST)} token marking the output carrying the state
        of the protocol on-chain, whose name is the well known string
        \texttt{HydraHeadV1}, i.e.
        $\st = \{\cid \mapsto \texttt{HydraHeadV1}\}$.\todo{value notation}
  \item One \emph{Participation Token (PT)} per participant
        $i \in \{1 \dots \nop \}$, where the token name is the participant's
        verification key hash $\keyHash_{i} = hash(\msVK_{i})$ using the
        verification key as received during protocol setup, i.e.
        $\pt_{i} = \{\cid \mapsto \keyHash_{i}\}$.
\end{itemize}

\noindent Consequently, the \mtxInit{} transaction

\begin{itemize}
  \item has at least input $i_{seed}$,
  \item mints one $\st$ and one $\pt$ for each of the $\nop$ participants with
        policy $\cid :: \{\st, \pt_{1}, \ldots, \pt_{\nop}\}$,
  \item has one state-machine output locked by $\nuHead$ with datum
        $\datum_{\mathsf{head}}$,
  \item has $\nop$ outputs, where each output is locked by $\nuInitial$ and the
        $\ith i$ output has the participation token $\pt_i$ in its value, and
        $\cid$ as datum.
\end{itemize}

\noindent The initial state of the protocol is captured in the state-machine output datum
\[
  \datum_{\mathsf{head}} = (\stInitial,\cid,\hydraKeysAgg,\nop,\cPer)
\]
where
\begin{mitemize}
  \item $\stInitial$ is a state identifier,
  \item $\cid$ is the unique currency id of this instance,
  \item $\hydraKeysAgg$ is the aggregated off-chain multi-signature key established during the
  setup phase,
  $(k_1,\ldots,k_\nop)$ exchanged during the setup phase and identifying the
  head members on-chain,
  \item $\nop$ is the number of head participants, and
  \item $\cPer$ is the length of the contestation period.
\end{mitemize}

\noindent \textbf{Important:} While the $\muHead$ minting policy ensures
uniqueness of $\cid$, the contents of the $\datum_{\mathsf{head}}$ are not
checked on-chain. All head members are expected to check whether the initial
state has the right $\cid$, is consistent with parameters agreed during setup
and whether the right amount of tokens have been minted and payed to $\nuHead$
and $\nuInitial$ respectively. From there, these validators ensure that the
output is consumed by either an \mtxAbort{}~\ref{sec:abort-tx} or a
\mtxCom{}~\ref{sec:commit-tx} transaction.

\input{fig_SM_commit_tx}

\subsection{Commit Transaction}\label{sec:commit-tx}

A \mtxCom{} transaction may be submitted by each participant
$\forall i \in \{1 \dots \nop\}$ and is depicted on the right hand side of
Figure~\ref{fig:SM_commit_tx}. It has the following structure:
\begin{itemize}
  \item One input $i_{initial} = (\txOutRef_{initial}, \redeemer_{initial})$
        spending $o_{initial} = (\val_{initial}, \nuInitial, \datum_{initial})$
  \item Zero or one\todo{allow more? need individual abort} input with reference
        $\txOutRef_{commit}$ spending output
        $o_{committed} = (\val_{committed}, \cdot , \cdot)$
  \item One output $o_{commit} = (\val_{commit}, \nuCommit, \delta_{commit})$
\end{itemize}

\noindent The $\nuInitial$ validator ensures that:
\begin{menumerate}
  \item The initial datum provides the currency id $\cid = \datum_{initial}$
  \item The initial redeemer references the committed output $\redeemer_{initial} = \txOutRef_{committed}$
  \item The committed value is in the output $\val_{com} = \val_{initial} \cup \val_{committed}$
  \item The currencty id and committed output are recorded in the output datum
  $\delta_{commit} = (\cid, U_{i})$ where
  $U_{i} = (\txOutRef_{committed},\bytes(o_{committed}))$
  \item Transaction is signed by a participant $\exists \{\cid \mapsto \keyHash_{i} \mapsto 1\} \in \val_{commit} \Rightarrow \keyHash_{i} \in \txKeys$
  \item No minting or burning  $\txMint = \varnothing$
\end{menumerate}

\noindent The $\nuCommit$ validator ensures the output is collected by either a \mtxCCom{}~\ref{sec:collect-tx} or \mtxAbort{}~\ref{sec:abort-tx} transaction of the on-chain state machine, selected by the appropriate redeemer.

\subsection{CollectCom Transaction}\label{sec:collect-tx}

\input{fig_SM_initial_open}

\noindent The \mtxCCom{} transaction collects all the committed UTxOs to the same head. It has
\begin{itemize}
  \item one input spending from $\nuHead$ holding the $\st$, and
  \item $\forall i \in \{1 \dots \nop\}$ inputs spending \mtxCom{} outputs $(\val_{commit_i}, \nuCommit, (\cid, U_{i}))$ with $\pt_{i} \in \val_{commit_{i}}$.
\end{itemize}
The input spending from and paying to the $\nuHead$ validator, checks the state
of the CEM is advanced:
\[
   (\stInitial,\cid,\hydraKeysAgg,\nop,\cPer) \xrightarrow{\mathsf{collectCom}} (\stOpen,\cid,\hydraKeysAgg,\nop,\cPer,\eta)
\]

\noindent Furthermore, $\nuHead$ checks these constraints:
\begin{menumerate}
  \item Collect commits in $\eta = (0, U^{\#})$, where
  $U^{\#} = \combine([U_{1}, \dots, U_{\nop}])$. That is, the hash, of the
  concatenation, of the serialised representation of a list of $\underline{U}$,
  which are sorted by their associated $\txOutRef$\footnote{Sorting is required
    to ensure a canonical representation which can also be reproduced from the
    UTxO set later in the fanout.}: \todo{define sortByOutRef?}\todo{off-chain use of this is different (on a UTxO set)}
  \[
    \combine(\underline{U}) = \hash(\concat \sortByOutRef(\underline{U}))
  \]
  \item All committed value captured and no additional funds ``enter'' or ``leave''\\
  $\val' = \mathsf{ST} \cup (\bigcup_{i=1}^{n} \val_{commit_i})$
  \item All tokens present in output\footnote{This is sufficient as a Head participant would check off-chain whether a Head is initialized correctly with the right number of tokens.}
  $|\{\cid \rightarrow . \rightarrow 1\} \in \val'| = \nop + 1$
  \item Transaction is signed by a participant $\exists \{\cid \mapsto \keyHash_{i} \mapsto 1\} \in \val_{commit} \Rightarrow \keyHash_{i} \in \txKeys$
  \item No minting or burning  $\txMint = \varnothing$
\end{menumerate}

\noindent Each spent $\nuCommit$ validator ensures that:
\begin{menumerate}
  \item The state token is present in the output value
  $\{\st \mapsto 1\} \in \val'$, where $(\cid,\cdot) = \delta_{commit}$ is given
  by the datum of the commit output $o_{commit}$.
\end{menumerate}

\subsection{Abort Transaction}\label{sec:abort-tx}

\input{fig_SM_initial_final.tex}

The \mtxAbort{} transaction (see Figure~\ref{fig:SM_initial_final}) allows a
party to abort the creation of a head. It is comprised of
\begin{itemize}
  \item one input spending from $\nuHead$ holding the $\st$, and
  \item $\forall i \in \{1 \dots \nop\}$ inputs either
    \begin{itemize}
      \item spending from an initial output $(\val_{initial_i}, \nuInitial, \cid)$ with $\pt_{i} \in \val_{initial_i}$, or
      \item spending from a commit output $(\val_{commit_i}, \nuCommit, \datum_{commit_i})$ with $\pt_{i} \in \val_{commit_{i}}$,
    \end{itemize}
  \item $m$ outputs to redistribute already committed UTxOs.
\end{itemize}
Note that \mtxAbort{} represents a final transition of the CEM and hence there
is no state machine output. The input spending from $\nuHead$ does provide the
number of reimbursed outputs $m$ as redeemer \todo{m is implicit, not required as redeemer} and checks the state of the CEM is
advanced to the final $\stFinal$ as follows:

\[
   (\stInitial,\cid,\hydraKeysAgg,\nop,\cPer) \xrightarrow[m]{\mathsf{abort}} \stFinal.
\]

\noindent The $\nuHead$ validator ensures that:
\begin{menumerate}
  \item All UTxOs committed into the head are reimbursed exactly as they were
  committed. By comparing hashes of serialised representations of the $m$
  reimbursing outputs\footnote{Only the first $m$ outputs are used for
    reimbursing, while more outputs may be present in the transaction, e.g for
    change} and canonically combined committed UTxOs $U_{i}$ where $(\cdot, U_{i}) = \datum_{commit_{i}}$ from \mtxCom{}~\ref{sec:commit-tx}:
  \todo{list/tuple comprehensions?}
  \[
    \hash(\bigoplus_{j=1}^{m} \bytes(\txOutputs[j])) = \combine([U_{i} ~ | ~ \forall [1\dots\nop], U_{i} \neq \bot])
  \]

  \item Transaction is signed by a participant $\exists \{\cid \mapsto \keyHash_{i} \mapsto -1\} \in \txMint \Rightarrow \keyHash_{i} \in \txKeys$
  \item All tokens are burnt
  $|\{\cid \mapsto \cdot \mapsto -1\} \in \txMint| = \nop + 1$
\end{menumerate}

\noindent Each $\nuInitial$ validator checks:\todo{datums/redeemers here?}
\begin{menumerate}
  \item The ST is getting burned $\{\st \mapsto -1\} \subseteq \txMint$, where
  $\cid$ is given by the datum of the spent initial output
  $\cid = \delta_{initial}$.
\end{menumerate}

\noindent Each $\nuCommit$ validators checks:
\begin{menumerate}
  \item The ST is getting burned $\{\st \mapsto -1\} \subseteq \txMint$, where
  $\cid$ is given by the datum of the spent commit output
  $(\cid,\cdot) = \delta_{commit}$.
\end{menumerate}

\subsection{Close Transaction}\label{sec:close-tx}

\input{fig_SM_open_closed}

In order to close a head, a head member may post the \mtxClose{} transaction
(see Figure~\ref{fig:SM_open_closed}). This transaction has a single input
spending from the $\nuHead$ and paying to the $\nuHead$ validator, which checks
the state of the CEM is advanced:
\[
  (\stOpen,\cid,\hydraKeysAgg,\nop,\cPer,\eta) \xrightarrow[\xi]{\mathsf{close}} (\stClosed,\cid,\hydraKeysAgg,\nop,\cPer,\eta_0,\eta',\contesters,\Tfinal)
\]

\noindent The $\nuHead$ validator performs these checks:
\begin{enumerate}
  \item Recorded the initial snapshot state $\eta_0 = \eta$
  \item New snapshot state $(s', \cdot) = \eta'$ is the initial $\eta_{0}$
        or correctly signed via $\xi$ \\
        \[
          \left\{\begin{array}{ll}
                  \msVfy(\hydraKeysAgg,(\cid || \eta_{0} || \eta'),\xi) = \true & \mathrm{if} ~ s' > 0, \\
                  \eta' = \eta_{0} & \mathrm{otherwise}
                 \end{array}\right.
        \]
  \item Initialize the set of contesters\footnote{This allows the closing party
        to also contest and is required for use cases where pre-signed, valid in
        the future, close transactions are used to delegate head closing}
        $\contesters = \emptyset$
  \item Correct contestation deadline $\Tfinal = \txRmax + T$
  \item Bounded confirmation window\footnote{Ensures head $\Tfinal$ is at most
        $2*T$ in the future} $\txRmax - \txRmin \leq T$
  \item Value in the head is preserved $\val' = \val$
  \item Transaction is signed by a participant $\exists \{\cid \mapsto \keyHash_{i} \mapsto 1\} \in \val' \Rightarrow \keyHash_{i} \in \txKeys$
  \item No minting or burning $\txMint = \varnothing$
\end{enumerate}

\subsection{Contest Transaction}\label{sec:contest-tx}

\input{fig_SM_closed_closed}

The \mtxContest{} transaction (see Figure~\ref{fig:SM_closed_closed}) is posted
by a party to prove the currently $\stClosed$ state is not the latest one. This
transaction has a single input spending from the $\nuHead$ and paying to the
$\nuHead$ validator, which checks the state of the CEM is advanced:
\[
  (\stClosed,\cid,\hydraKeysAgg,\nop,\cPer,\eta_0,\eta,\contesters,\Tfinal) \xrightarrow[\xi]{\mathsf{contest}} (\stClosed,\cid,\hydraKeysAgg,\nop,\cPer,\eta_0,\eta',\contesters',\Tfinal')
\]

\noindent The $\nuHead$ validator performs these checks:
\begin{menumerate}
  \item Contest snapshot is newer $s' > s$, where $(s, \cdot) = \eta$ is the current and $(s', \cdot) = \eta'$ is the contest snapshot number
  \item $\xi$ is a valid multi-signature of the new snapshot state
  $\msVfy(\hydraKeysAgg,(\cid || \eta_{0} || \eta'),\xi) = \true$
  \item The single signer $\{\keyHash\} = \txKeys$ has not already contested $\keyHash \not\in \contesters$ and is added to the set of contesters $\contesters' = \contesters \cup \keyHash$
  \item Transaction is posted before deadline $\txRmax \leq \Tfinal$
  \item Contestation deadline is updated correctly
     \[
       \Tfinal' = \left\{\begin{array}{ll}
                           \Tfinal     & \mathrm{if} ~ |\contesters'| = n, \\
                           \Tfinal + T & \mathrm{otherwise}
                         \end{array}\right.
    \]
  \item Transaction is signed by a participant $\exists \{\cid \mapsto \keyHash_{i} \mapsto 1\} \in \val' \Rightarrow \keyHash_{i} \in \txKeys$
  \item Value in the head is preserved $\val' = \val$
  \item No minting or burning $\txMint = \varnothing$
\end{menumerate}

\subsection{Fan-Out Transaction}

\input{fig_SM_closed_final}

\noindent Once the contestation phase is over, a head may be finalized by posting a
\mtxFanout{} transaction (see Figure~\ref{fig:SM_closed_final}), which
distributes UTxOs from the head according to the latest state. It consists of
\begin{itemize}
  \item one input spending from $\nuHead$ holding the $\st$, and
  \item $m$ outputs to fan-out UTxOs.
\end{itemize}
Note that \mtxFanout{} represents a final transition of the CEM and hence there
is no state machine output. The input spending from $\nuHead$ does provide the
number of fanned-out outputs $m$ as redeemer and checks the state of the CEM is
advanced to the final $\stFinal$ as follows:
\[
  (\stClosed,\cid,\hydraKeysAgg,\nop,\cPer,\eta_0,\eta,\contesters,\Tfinal) \xrightarrow[m]{\mathsf{fanout}} \stFinal,
\]

\noindent The $\nuHead$ validator performs these checks:
\begin{enumerate}
  \item The first $m$ outputs are distributing funds according to
        $(\cdot, U^{\#}) = \eta$. That is, the outputs correspond (in the same
        order) to the UTxO canonically combined (see~\ref{sec:collect-tx}) into
        $U^{\#}$
        \[
        \hash(\bigoplus_{j=1}^{m} \bytes(\txOutputs[j])) = U^{\#}
        \]
  \item Transaction is posted after contestation deadline $\txRmin > \Tfinal$
  \item All tokens are burnt
        $|\{\cid \mapsto \cdot \mapsto -1\} \in \txMint| = n + 1$
\end{enumerate}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
