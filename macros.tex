% ==== Hydra Macros ====

% NOTE: New macro file; please copy and keep organized macros from
% macros_old.tex as needed.  Hopefully, this will result in tidier
% macros file.
%
% Index:
% - Misc
% - General
% - Theorem Environments
% - Multisignatures
% - Transactions
% - State Machines
% - Head Protocol
% - On-Chain Verification
% - Algorithms
% - Merkle-Patricia Trees

% === engineering ===
\newcommand{\undefined}{\mathrm{undef}}


% === Misc ===

\newcommand{\algoskip}{\vspace{4pt}}

\newcommand{\ignore}[1]{}

\newcommand{\TODO}[1]{
  \if\relax\detokenize{#1}\relax
    \textcolor{red}{TODO}
  \else
    \textcolor{red}{ {#1}}
  \fi
}

\newcommand{\fail}{\mbox{fail}}

% from https://www.overleaf.com/latex/examples/simple-stylish-box-design/stzmmcshxdng
\definecolor{main}{HTML}{5989cf}    % setting main color to be used
\definecolor{sub}{HTML}{cde4ff}     % setting sub color to be used
\newtcolorbox{boxM}{
    fontupper = \color{white},
    rounded corners,
    arc = 6pt,
    colback = main!80, 
    colframe = main, 
    boxrule = 0pt, 
    bottomrule = 4.5pt,
    enhanced,
    fuzzy shadow = {0pt}{-3pt}{-0.5pt}{0.5pt}{black!35}
}

% In figures, this makes algorithms work with option [H] despite
% double-column format
% https://tex.stackexchange.com/questions/82271/multiple-algorithm2e-algorithms-in-two-column-documents
\makeatletter
\newcommand{\removelatexerror}{\let\@latex@error\@gobble}
\makeatother

\newcommand{\md}{\textsf{-}}

\newcommand{\fst}[1]{#1^{\text{st}}}
\newcommand{\snd}[1]{#1^{\text{nd}}}
\newcommand{\trd}[1]{#1^{\text{rd}}}
\newcommand{\ith}[1]{#1^{\text{th}}}

\newcommand{\eps}{\varepsilon}
\newcommand{\mc}{\mathcal}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}


% === General ===
\newcommand{\ol}[1]{\overline{#1}}

\newcommand{\true}{\mathtt{true}}
\newcommand{\false}{\mathtt{false}}

\newcommand{\spara}{k}

\newcommand{\nop}{n}
\newcommand{\party}{\mathsf p}
\newcommand{\parties}{\mathcal{P}}

\newcommand{\adv}{\ensuremath{\mathcal{A}}}
\newcommand{\att}{\adv}
\newcommand{\advLive}{\ensuremath{\mathcal{A}}_{\mathsf L}}

\newcommand{\propName}{\textsc}

\newcommand{\hout}[1]{h_{\mathsf{out},#1}}
\newcommand{\hrest}{h_{\mathsf{rest}}}

\newcommand{\es}{\eps}

\newcommand{\hash}{\mathsf{hash}}
\newcommand{\bytes}{\mathsf{bytes}}


% === Theorem Environments ===

\newtheoremstyle{putaneffinperiod}% name of the style to be used
  {\topsep}% measure of space to leave above the theorem. E.g.: 3pt
  {\topsep}% measure of space to leave below the theorem. E.g.: 3pt
  {\itshape}% name of font to use in the body of the theorem
  {0pt}% measure of space to indent
  {\bfseries}% name of head font
  {.}% punctuation between head and body
  {1em}% space after theorem head; " " = normal interword space
  {\thmname{#1}\thmnumber{ #2}\thmnote{ (#3)}}
\theoremstyle{putaneffinperiod}

\newtheorem{theorem}{Theorem}
% \numberwithin{theorem}{chapter}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{definition}{Definition}
% \numberwithin{definition}{chapter}
\newtheorem{invariant}{Invariant}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{postulate}{Postulate}
\theoremstyle{definition}
\newtheorem{example}{Example}
\newtheorem{construction}{Construction}


% === Transactions  ===

\newcommand{\tx}{\mathrm{tx}}
\newcommand{\txA}{\mathrm{txA}}
\newcommand{\txB}{\mathrm{txB}}
\newcommand{\validTx}{\mathsf{valid\md{}tx}}
\newcommand{\applytx}{\circ}
\newcommand{\Reach}{\mathsf{Reach}}
\newcommand{\uid}{\mathsf{uid}}

\newcommand{\txVal}{\mathsf{val}}		% currency value
\newcommand{\txValForge}{\txVal_\mathsf{Mint}}	% mint value
\newcommand{\txValBurn}{\txVal_\mathsf{Burn}}	% forge value
\newcommand{\txTx}{\mathit{tx}}			% transaction value
\newcommand{\txTxTy}{\mathit{Tx}}		% transaction type
\newcommand{\txValTy}{\mathit{Val}}		% currency value type
\newcommand{\txCIdTy}{\mathit{CId}}		% currency identifier type
\newcommand{\txTokenTy}{\mathit{Token}}	        % currency token type
\newcommand{\txKeys}{\mathcal K}		% (public) keys with a
                                                % valid signature on
                                                % the tx
\newcommand{\txOutRef}{\mathsf{out\md{}ref}}
\newcommand{\txID}{\mathit{txID}}
\newcommand{\ID}{\mathsf{ID}}
\newcommand{\txIdx}{\mathit{txIdx}}
\newcommand{\txR}{r}
\newcommand{\txRmin}{r_{\mathsf{min}}}
\newcommand{\txRmax}{r_{\mathsf{max}}}

\newcommand{\tyBool}{\mathbb{B}}
\newcommand{\tyData}{\mathsf{Data}}
\newcommand{\tyBytes}{\mathbb{H}}
\newcommand{\txPendingTx}{\sigma}
\newcommand{\txPendingTxTy}{\mathit{PendingTx}}
\newcommand{\txIpend}{i_{\mathsf{pend}}}
\newcommand{\txIpendSet}{I_{\mathsf{pend}}}

\newcommand{\Tset}{T}
\newcommand{\Uset}{U}
\newcommand{\Uinit}{\Uset_{0}}
\newcommand{\Ufinal}{\Uset_{\mathsf{final}}}

\newcommand{\recordUTxO}{\mathsf{recordUTxO}}

% === Multisignatures ===

\newcommand{\ms}{\mathsf{MS}}

\newcommand{\msSetup}{\mathsf{MS\md{}Setup}}
\newcommand{\msKeyGen}{\mathsf{MS\md{}KG}}
\newcommand{\msSign}{\mathsf{MS\md{}Sign}}
\newcommand{\msVfy}{\mathsf{MS\md{}Verify}}
\newcommand{\msComb}{\mathsf{MS\md{}ASig}}
\newcommand{\msCombVK}{\mathsf{MS\md{}AVK}}
\newcommand{\msCombVfy}{\mathsf{MS\md{}AVerify}}

\newcommand{\msParams}{\Pi}
\newcommand{\msSig}{\sigma}
\newcommand{\msSigL}{\Sigma}
\newcommand{\msCSig}{\tilde\sigma}
\newcommand{\msVK}{k^{ver}}
\newcommand{\msCVK}{\tilde{k}}
\newcommand{\msVKL}{\mathcal{V}}
\newcommand{\msSK}{k^{sig}}
\newcommand{\msMsg}{m}


% === Signatures ===
\newcommand{\initial}[1]{\dot{#1}}
%\newcommand{\chain}[1]{\dot{#1}}

\newcommand{\sVK}{k_{\pu}}
\newcommand{\sVKI}[1]{k_{#1,\pu}}
\newcommand{\sVKII}[1]{\initial{k}_{#1,\pu}}
\newcommand{\sSK}{k_{\pr}}
\newcommand{\sSKI}[1]{k_{#1,\pr}}
\newcommand{\sSKII}[1]{\initial{k}_{#1,\pr}}

% === State Machines ===

\newcommand{\cemS}{S_{\textsc{cem}}}
\newcommand{\cemI}{I_{\textsc{cem}}}
\newcommand{\cemIn}{i_{\textsc{cem}}}
\newcommand{\cemOut}{o_{\textsc{cem}}}
\newcommand{\cemVal}{\nu_{\textsc{cem}}}
\newcommand{\cemFinal}{\mathit{final}_{\textsc{cem}}}
\newcommand{\cemStep}{\mathit{step}_{\textsc{cem}}}
\newcommand{\cemStepRel}[4]{{#1}\overset{#2}\longrightarrow(#3, #4)}
\newcommand{\cemTxCon}{\tx^\equiv}


% == Transactions ==

\newcommand{\mtxInit}{\textit{initial}}
\newcommand{\mtxCom}{\textit{commit}}
\newcommand{\mtxCommit}{\textit{commit}}
\newcommand{\mtxCCom}{\textit{collectCom}}
\newcommand{\mtxCollect}{\textit{collectCom}}
\newcommand{\mtxIncrement}{\textit{increment}}
\newcommand{\mtxDecrement}{\textit{decrement}}
\newcommand{\mtxAbort}{\textit{abort}}
\newcommand{\mtxClose}{\textit{close}}
\newcommand{\mtxContest}{\textit{contest}}
\newcommand{\mtxFinalize}{\textit{finalize}}
\newcommand{\mtxFanout}{\textit{fanout}}
\newcommand{\mtxSplit}{\textit{split}}
\newcommand{\mtxCSN}{\textit{collectSN}}
\newcommand{\mtxCHT}{\textit{collectHT}}
\newcommand{\mtxSN}{\textit{SN}}
\newcommand{\mtxHT}{\textit{HT}}


% == States ==

\newcommand{\stInitial}{\mathsf{initial}}
\newcommand{\stOpen}{\mathsf{open}}
\newcommand{\stClosed}{\mathsf{closed}}
\newcommand{\stSnap}{\mathsf{newestSN}}
\newcommand{\stFinal}{\mathsf{final}}

\newcommand{\hMT}{h_{\mathsf{MT}}}
\newcommand{\piMT}{\pi_{\mathsf{MT}}}
\newcommand{\cPer}{T}
\newcommand{\Tfinal}{T_{\mathsf{final}}}
\newcommand{\Tsnapshot}{T_{\mathsf{newestSN}}}
\newcommand{\contesters}{\mathcal C}
\newcommand{\val}{\mathsf{val}}


% == Inputs ==

\newcommand{\stCollect}{\mathsf{collect}}
\newcommand{\stClose}{\mathsf{close}}
\newcommand{\stContest}{\mathsf{contest}}
\newcommand{\stFanout}{\mathsf{fanout}}
\newcommand{\stAbort}{\mathsf{abort}}


% == Validators ==

\newcommand{\muHead}{\mu_\mathsf{Head}}
\newcommand{\nuSetup}{\nu_\mathsf{initial}} % TODO: remove
\newcommand{\nuInitial}{\nu_\mathsf{initial}}
\newcommand{\nuHead}{\nu_\mathsf{head}}
\newcommand{\nuCom}{\nu_\mathsf{com}}
\newcommand{\nuClose}{\nu_\mathsf{closed}}
\newcommand{\nuSnap}{\nu_\mathsf{SN}}
\newcommand{\nuNewname}{\nu_\mathsf{newestSN}}
\newcommand{\nuHang}{\nu_\mathsf{HT}}
\newcommand{\nuFinal}{\nu_\mathsf{final}}


% === Head Protocol ===

% == Algorithms ==

\newcommand{\HP}{\mathsf{HP}}
\newcommand{\hpSetup}{\mathsf{Setup}}
\newcommand{\hpKG}{\mathsf{KeyGen}}
\newcommand{\hpAgg}{\mathsf{Agg}}
\newcommand{\hpProt}{\mathsf{Prot}}


% == Protocol ==

\newcommand{\hpInit}{\mathtt{init}}
\newcommand{\hpNew}{\mathtt{new}}
\newcommand{\hpSeen}{\mathtt{seen}}
\newcommand{\hpConf}{\mathtt{conf}}
\newcommand{\hpClose}{\mathtt{close}}
\newcommand{\hpCont}{\mathtt{cont}}
\newcommand{\hpFO}{\mathtt{fanOut}}

\ignore{
\newcommand{\obj}{\Omega}

\newcommand{\certreq}{\ensuremath{\mathtt{sigReq}}}
\newcommand{\certack}{\ensuremath{\mathtt{sigAck}}}
\newcommand{\certconf}{\ensuremath{\mathtt{sigConf}}}

\newcommand{\abortreq}{\ensuremath{\mathsf{abortReq}}}

\newcommand{\init}{\mathbf{Init}}
\newcommand{\gencert}{\mathbf{GenCert}}

\newcommand{\txobj}{\mathsf{txo}}
\newcommand{\genobj}{\mathsf{obj}}
\newcommand{\genset}{\mathsf{ObjSet}}
\newcommand{\gentxobj}{\mathsf{GenTxObj}}
\newcommand{\stateobj}{\ensuremath{u}}
\newcommand{\ack}{\mathsf{ack}}
}

% == Variables ==
\newcommand{\pu}{\mathsf{ver}}
\newcommand{\pr}{\mathsf{sig}}


\newcommand{\hpParams}{\Sigma}
\newcommand{\hpPu}{K_{\pu}}
\newcommand{\hpPuv}{\underline{K}_\pu}
\newcommand{\hpPui}[1]{K_{\pu,#1}}
\newcommand{\hpPr}{K_{\pr}}
\newcommand{\hpPri}[1]{K_{\pr,#1}}
\newcommand{\hpAK}{K_{\mathsf{agg}}}
\newcommand{\hpAKI}{\initial{K}_{\mathsf{agg}}}

\newcommand{\hpPuvInit}{\initial{\underline{K}}_\pu}

\newcommand{\hpAKchain}{\hpAK^{\mathsf{chain}}}
\newcommand{\hpAKinit}{\hpAK^{\mathsf{setup}}}

%\newcommand{\initial}{\mathsf{init}}
\newcommand{\daPuII}[1]{\initial{K}_{#1,\pu}}
\newcommand{\daPrII}[1]{\initial{K}_{#1,\pr}}
%\newcommand{\sVKI}{\mathsf{vk}^{\initial}}
%\newcommand{\sSKI}{\mathsf{sk}^{\initial}}

\newcommand{\hppuv}{\underline{k}_\pu}
\newcommand{\hppuvinit}{\initial{\underline{k}}_\pu}


\newcommand{\hats}{\hat s}
\newcommand{\bars}{\overline s}
\newcommand{\hatmU}{\hat {\mathcal U}}
\newcommand{\barmU}{\overline {\mathcal U}}
\newcommand{\mL}{{\mathcal L}}
\newcommand{\hatmL}{\hat {\mathcal L}}
\newcommand{\barmL}{\overline {\mathcal L}}
\newcommand{\mT}{{\mathcal T}}
\newcommand{\hatmT}{\hat {\mathcal T}}
\newcommand{\barmT}{\overline {\mathcal T}}
\newcommand{\hatmDT}{\Delta\hat {\mathcal T}}
\newcommand{\hatmR}{\hat {\mathcal R}}
\newcommand{\mH}{{\mathcal H}}

\newcommand{\TR}{T_{\mathsf R}}
\newcommand{\tTR}{\tilde T_{\mathsf R}}
\newcommand{\tR}{\tilde R}

\newcommand{\hpSigs}{S}

\newcommand{\txo}{\mathsf{tx}}


% == Commands ==

\newcommand{\hpRG}{\mathtt{req}}
\newcommand{\hpAG}{\mathtt{ack}}
\newcommand{\hpCG}{\mathtt{conf}}

\newcommand{\hpRT}{\mathtt{reqTx}}
\newcommand{\hpAT}{\mathtt{ackTx}}
\newcommand{\hpCT}{\mathtt{confTx}}

\newcommand{\hpNS}{\mathtt{newSn}}
\newcommand{\hpRS}{\mathtt{reqSn}}
\newcommand{\hpAS}{\mathtt{ackSn}}
\newcommand{\hpCS}{\mathtt{confSn}}


% == Functions ==

\newcommand{\Txo}{\mathsf{txObj}}
\newcommand{\Sno}{\mathsf{snObj}}
\newcommand{\ApplyMax}{\mathsf{uApplyMax}}

\newcommand{\hpLdr}{\mathsf{leader}}
\newcommand{\hpMT}{\mathsf{maxTxos}}

\newcommand{\conf}{\mathsf{conflict}}
\newcommand{\confTx}{\mathsf{conflict\md{}tx}}

% serialisation
\newcommand{\bits}{\mathsf{bits}}

% == Projectors ==

\newcommand{\hpProj}{_{\downarrow (\tx,\msCSig)}}
\newcommand{\hpProjT}{_{\downarrow (\tx)}}
\newcommand{\hpProjH}{_{\downarrow (\hash)}}
\newcommand{\hpProjSig}{_{\downarrow (\msCSig)}}
\newcommand{\hpProjHs}{_{\downarrow (\hash,\msCSig)}}
\newcommand{\hpProjSo}{_{\downarrow (s,\outputset)}}
\newcommand{\hpProjSos}{_{\downarrow (s,\outputset,\msCSig)}}

\renewcommand{\hpProj}{^{\downarrow (\tx,\msCSig)}}
\renewcommand{\hpProjT}{^{\downarrow (\tx)}}
\renewcommand{\hpProjH}{^{\downarrow (\hash)}}
\renewcommand{\hpProjSig}{^{\downarrow (\msCSig)}}
\renewcommand{\hpProjHs}{^{\downarrow (\hash,\msCSig)}}
\renewcommand{\hpProjSo}{^{\downarrow (s,\outputset)}}
\renewcommand{\hpProjSos}{^{\downarrow (s,\outputset,\msCSig)}}


% == Security ==

\newcommand{\Ttilde}{\tilde{T}}
\newcommand{\That}{\hat{T}}
\newcommand{\Tbar}{\overline{T}}
\renewcommand{\Ttilde}{\tilde{S}}
\renewcommand{\That}{\hat{S}}
\renewcommand{\Tbar}{\overline{C}}

\newcommand{\TxNewAll}{{\cal N}}

\newcommand{\Hcont}{H_{\mathsf{cont}}}
\newcommand{\honest}{\mathcal H}
\newcommand{\contSet}{\mathcal C}
\newcommand{\Cchain}{C_{\mathsf{chain}}}
\newcommand{\USN}[1]{\mathrm{SN}_{#1}}
\newcommand{\setSN}[1]{\tilde T_{#1}}
\newcommand{\curSN}[1]{\mathrm{SN}_{\mathsf{cur},#1}}

\newcommand{\INV}[1]{\mathsf{INV}_{#1}}

\newcommand{\atti}[1]{^{(#1)}}

% === Mediator Protocol ===
\newcommand{\gcClientNewHead}{\mathtt{clientNewHead}}
\newcommand{\gcClientTx}{\mathtt{clientTx}}
\newcommand{\gcClientClose}{\mathtt{closeTx}}
\newcommand{\gcChainInitial}{\mathtt{initialTx}}
\newcommand{\gcChainCollectCom}{\mathtt{collectComTx}}
\newcommand{\gcChainClose}{\mathtt{closeTx}}
\newcommand{\gcChainContest}{\mathtt{contestTx}}
\newcommand{\gcChainFanout}{\mathtt{fanoutTx}}
\newcommand{\gcChainAbort}{\mathtt{abortTx}}
\newcommand{\gcChainCommit}{\mathtt{commitTx}}
\newcommand{\gcChainInitialTO}{\mathtt{chainInitialTimeOut}}
\newcommand{\gcChainClosedTO}{\mathtt{chainClosedTimeOut}}

\newcommand{\gcChainRef}{\mathsf{chain}}
\newcommand{\gcClientRef}{\mathsf{client}}
\newcommand{\gcHeadRef}{\mathsf{head}}
\newcommand{\gcChainPost}{\mathsf{postTx}}
\newcommand{\gcUTXOset}{\mathsf{UTxOs}}
\SetKw{Call}{call}


% === On-Chain Verification ===

% == Algorithms and Oracles ==

\newcommand{\ocvInitial}{\mathsf{Initial}}
\newcommand{\ocvFinalize}{\mathsf{Finalize}}
\newcommand{\ocvClose}{\mathsf{Close}}
\newcommand{\ocvContest}{\mathsf{Contest}}
\newcommand{\ocvFinal}{\mathsf{Final}}

\newcommand{\ocvIncrement}{\mathsf{Increment}}
\newcommand{\ocvDecrement}{\mathsf{Decrement}}

\newcommand{\ocvSnapshot}{\mathsf{Snapshot}}
\newcommand{\ocvValidSnap}{\mathsf{ValidSN}}
\newcommand{\ocvValidHang}{\mathsf{ValidHT}}

\newcommand{\ocvClaim}{\mathsf{Claim}}
\newcommand{\ocvAllocate}{\mathsf{Allocate}}
\newcommand{\ocvFanout}{\mathsf{Fanout}}

\SetKwFor{OocvInitial}{$\ocvInitial$}{}{enddo}
\SetKwFor{OocvFinalize}{$\ocvFinalize$}{}{enddo}
\SetKwFor{OocvClose}{$\ocvClose$}{}{enddo}
\SetKwFor{OocvContest}{$\ocvContest$}{}{enddo}
\SetKwFor{OocvFinal}{$\ocvFinal$}{}{enddo}

\SetKwFor{OocvClaim}{$\ocvClaim$}{}{enddo}
\SetKwFor{OocvAllocate}{$\ocvAllocate$}{}{enddo}
\SetKwFor{OocvFanout}{$\ocvFanout$}{}{enddo}


% == Variables ==

\newcommand{\hInit}{\hash_{\mathsf{init}}}
\newcommand{\imax}{i_{\mathsf{max}}}
\newcommand{\symFinal}{\mathtt{final}}


% == Functions ==

\newcommand{\applicable}{\mathsf{applicable}}


% === Algorithms ===

% == Misc ==

% \setlength{\algomargin}{0em}


% == Boxes ==

\newenvironment{algobox}[1]%
{
  \begin{tabularx}{\textwidth}{X c X}
    \hline
    \rowcolor{gray!20} 
    & \textbf{#1} & \\
    \hline
  \end{tabularx}
  
  \vspace{-1.5em}

  \begin{center}
}
{
  \end{center}

  \vspace{-1.5em}

  \begin{tabularx}{\textwidth}{X c X}
    \hline
  \end{tabularx}

  \vspace{0.5em}
}

\newenvironment{walgo}[1]%
{
  \begin{minipage}{#1\linewidth}
    \begingroup
    \removelatexerror% Nullify \@latex@error
    \begin{algorithm}[H]  
}
{
    \end{algorithm}
    \endgroup
  \end{minipage}
}


% == Keywords ==

\SetKwFor{Check}{check}{}{enddo}


% == DA Game ==

%\newcommand{\algoskip}{\vspace{2pt}}

\SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{end if}
\SetKwFor{For}{for}{}{end for}

\SetKwFor{On}{on}{}{enddo}
\SetKwFor{Function}{function}{}{enddo}
\SetKwFor{PFunction}{public function}{}{enddo}
\SetKw{Out}{output}
\SetKw{Req}{require}
\SetKwFor{ForA}{for all}{}{enddo}
\SetKwFor{Wait}{wait}{}{enddo}
\SetKw{KwWait}{wait} % without body
\SetKw{IfI}{if}
\SetKw{ThenI}{then}
\SetKw{ElsI}{else}
\SetKw{FiI}{fi}

\newcommand{\daPID}{\mathsf{ID}}

\newcommand{\daGlobal}{\Sigma}
\newcommand{\daPu}{K_{\pu}}
\newcommand{\daPuV}{\overline K_{\pu}}
\newcommand{\daPuI}[1]{K_{#1,\pu}}
\newcommand{\daPr}{K_{\pr}}
\newcommand{\daPrI}[1]{K_{#1,\pr}}

\newcommand{\daCInit}{\mathtt{init}}
\newcommand{\daCNew}{\mathtt{new}}
\newcommand{\daCSeen}{\mathtt{seen}}
\newcommand{\daCConf}{\mathtt{conf}}
\newcommand{\daCCert}{\mathtt{cert}}
\newcommand{\daCComp}{\mathtt{comp}}

\SetKw{New}{new}
\SetKw{KwOn}{on}
\SetKw{Send}{send}
\SetKw{Multi}{multicast}
\SetKw{PostTx}{postTx}
\newcommand{\Store}{\mathsf{store}}
\newcommand{\Sign}{\mathsf{sign}}
\newcommand{\Combine}{\mathsf{sigCombine}}
\newcommand{\Verify}{\mathsf{SigVerify}}
\newcommand{\Complete}{\mathsf{Complete}}

\newcommand{\hyPu}{\msCVK}
\newcommand{\hyPr}{\msSK}


% === Merkle-Patricia Trees ===

% == Misc ==

\newcommand{\MPTalph}{A}

% == Algorithms ==

\newcommand{\MPTInit}{\mathsf{MPT\md{}Init}}
\newcommand{\MPTHash}{\mathsf{MPT\md{}Hash}}
\newcommand{\MPTMemb}{\mathsf{MPT\md{}Memb}}

\newcommand{\MPTBuild}{\mathsf{MPT\md{}Build}}
\newcommand{\MPTPath}{\mathsf{MPT\md{}Path}}


% == Hash Computations ==

\newcommand{\MPTverMemb}{\mathsf{MPT\md{}VfyMemb}}
\newcommand{\MPTcompRA}{\mathsf{MPT\md{}CompRA}}
\newcommand{\MPTcompSpl}{\mathsf{MPT\md{}CompSpl}}


% == Helpers ==

\newcommand{\CP}{\mathsf{CP}}
\newcommand{\RP}{\mathsf{RP}}
\newcommand{\Proj}{\mathsf{Proj}}
\newcommand{\Sum}{\mathsf{Sum}}
\newcommand{\Size}{\mathsf{Size}}
\newcommand{\First}{\mathsf{First}}


% == Oracles ==

\SetKwFor{MPTAInit}{\sf MPT-Init}{}{enddo}

\SetKwBlock{MPTAHash}{\sf MPT-Hash}{enddo}
\SetKwFor{MPTAMemb}{\sf MPT-Memb}{}{enddo}

\SetKwFor{MPTABuild}{\sf MPT-Build}{}{enddo}
\SetKwFor{MPTAPath}{\sf MPT-Path}{}{enddo}


% == Variables ==

\newcommand{\MPTroot}{h_{\mathsf{root}}}
\newcommand{\MPTnodes}{N}
\newcommand{\MPTpre}{\mathsf{pre}}
\newcommand{\MPTnode}{\mathsf{node}}
\newcommand{\MPTleaf}{\mathsf{leaf}}
\newcommand{\MPTkey}{k}
\newcommand{\MPTvalue}{v}
\newcommand{\MPTaux}{\mathsf{aux}}
\newcommand{\MPTsplit}{\mathsf{split}}




% == MF ==
\newcommand{\mf}[1]{{\color{red} {#1}}}
% \newcommand{\mfold}[1]{{\color{red}\sout{#1}}}
% \newcommand{\mfreplace}[2]{{\color{red}\sout{#1} {#2}}}
\newcommand{\symdif}{\stackrel{\cdot}{\cup}}
\newcommand{\defeq}{\stackrel{\triangle}{=}}
\newcommand{\sigmaterial}{\Phi}

\newcommand{\dparagraph}[1]{\smallskip\noindent\textbf{#1}}

\newcommand{\pvspace}{\vspace{8pt}}



% == Affiliations ==

\newcommand*\sameaffil[1][\value{footnote}]{\footnotemark[#1]}


% == Narrow Itemize ==
\newenvironment{sitemize}[1] %
  {\itemize\setlength\itemsep{0em}} %
  {\enditemize}

\newenvironment{senumerate} %
  {\enumerate\setlength\itemsep{0em}} %
  {\endenumerate}

\newenvironment{sdescription} %
  {\description\setlength\itemsep{0em}} %
  {\enddescription}

\newenvironment{mitemize} %
  {\itemize\setlength\itemsep{0.25em}} %
  {\enditemize}

\newenvironment{menumerate} %
  {\enumerate\setlength\itemsep{0.25em}} %
  {\endenumerate}

\newenvironment{mdescription} %
  {\description\setlength\itemsep{0.25em}} %
  {\enddescription}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
