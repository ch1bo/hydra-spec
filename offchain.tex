\section{Off-Chain Protocol}\label{sec:offchain}

This section describes the actual Coordinated Hydra Head protocol, an even more simplified version of the original publication \cite{hydrahead20}. See the protocol overview in Section \ref{sec:overview} for an introduction and notable changes to the original protocol.\\
\\
The protocol is specified as a reactive system that processes three kinds of events:
\begin{enumerate}
  \item on-chain protocol transactions introduced in the previous section (\ref{sec:on-chain}),
  \item off-chain network messages sent between protocol actors (parties), and
  \item client commands as received from the environment.
\end{enumerate}

The behavior is fully specified with corresponding sections in
Figure~\ref{fig:head_coordinated} using variables and notation introduced in the
following paragraphs.

\subsection{Assumptions}
\todo{move to protocol setup?}
\begin{itemize}
  \item Every network message received from a specific party is checked for
        authentication. An implementation of the specification needs to find a
        suitable means of (channel) authentication.
  \item The head protocol gets correctly (and with completeness) notified about
        observed transactions on-chain belonging to the respective head
        instance.
  \item The specification covers only a single instance of a Hydra Head.
        However, some implementations may choose to track multiple instances. As
        multiple Hydra Heads might exist on the same blockchain, it is vital
        that they do not interfere and the specification will take special care
        to ensure this.
  \item All events are processed to completion, i.e. run-to-completion semantics
        without preemption.
  \item Given the specification, events may pile up forever and implementations
        need to consider these situations (i.e. potential for DoS). Note that,
        from a security standpoint, these situations are identical to a
        non-collaborative peer.
  \item The lifecycle of a Hydra Head on-chain does not cross (hard fork)
        protocol update boundaries. Note that these events are announced in
        advance hence it should be possible for implementations to react in such
        a way as to expedite closing of the Head before such a protocol update.
        This further assumes that the contestation period parameter is picked
        accordingly.
\end{itemize}

\subsection{Notation}
\begin{itemize}
  \item ‘check P’ means that the following code is only executed if P holds and
        otherwise skipped
  \item ‘wait P’ is a blocking wait for condition P (we always use this in a way
        that implies dishonest participation if it does not terminate)
  \item All code blocks are assumed to be atomic
  \item ‘fail’ implies detection of cheating (i.e., head can be closed), no
        further requests or acknowledgments must be sent.
\end{itemize}



\subsection{Variables}

\begin{center}
\begin{tabular}{|l|l|}\hline
  $\hats$  & Sequence number of seen snapshot. \\ \hline
  $\bars$  & Sequence number of confirmed snapshot. \\ \hline
  $\hatmU$ & Seen snapshot object. \\ \hline
  $\barmU$ & Confirmed snapshot object. \\ \hline
  $\hatmL$ & Local ledger extension using seen transactions to prepare the next snapshot.\\ \hline
  $\mT$    & Set of all transactions ever received via reqTx (independent of their validity or mutual conflicts).\\  \hline
  $\hatmT$ & Set of transactions that extend the $\barmU$ (or $\hatmU$) to form $\hatmL$. \\
           & Transaction candidates that go into the next snapshot (if this party is the next leader).\\ \hline
  $\barmT$ & Set of all confirmed transactions up to the latest confirmed snapshot.\\  \hline
\end{tabular}
\end{center}

In particular, note, that the original variables $\hatmT$ and $\barmT$ are not required anymore because they
were used in context of hanging transactions. We thus reused them to fit the new context.

\input{fig_offchain_prot}[h]

Comments: 
\begin{itemize}
\item Fix: from client or from network: same function called twice should trigger at most one wait.
  For instance, $\hpRS$ called twice must not queue the 'wait' part for multiple execution.
\item Fix: $\hpNS$ called twice must not trigger local $\hpRS$ twice.
\item Add: garbage collection ($\hatmT,\barmT$,etc.)
\item Extensive code explanation (per line of code)
\end{itemize}

The following figure visualizes the possible event flows from the view of a single party.
\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth*2/3]%
                  {fig/reqackstates.png}
                  \caption{State diagram of reqSn/ackSn cycles.}
                  \label{fig:sim:baselines}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
