\section{Off-Chain Protocol}\label{sec:offchain}

\todo{explain off-chain before on-chain?}
This section describes the actual Coordinated Hydra Head protocol, an even more
simplified version of the original publication~\cite{hydrahead20}. See the
protocol overview in Section~\ref{sec:overview} for an introduction and notable
changes to the original protocol. While the on-chain part already describes the
full life-cycle of a Hydra head on-chain, this section completes the picture by
defining how the protocol behaves off-chain and notably the relationship between
on- and off-chain semantics. The protocol is specified as a reactive system that
processes three kinds of events:
\begin{enumerate}
  \item on-chain protocol transactions as introduced in
        Section~\ref{sec:on-chain}, which are posted to the mainchain and can be
        observed by all actors
  \item off-chain network messages sent between protocol actors (parties):
    \begin{itemize}
      \item $\hpRT$: to request a transaction to be included in the next snapshot
      \item $\hpRS$: to request a snapshot to be created \& signed by every head member
      \item $\hpAS$: to acknowledge a snapshot by replying with their signatures
    \end{itemize}
  \item client commands as received from the environment
    \begin{itemize}
      \item $\hpInit$: to start initialization of a head
      \item $\hpNew$: to submit a new transaction to an open head
      \item $\hpClose$: to request closure of an open head
    \end{itemize}
\end{enumerate}
\todo{add a state diagram?}

The behavior is fully specified in Figure~\ref{fig:head_coordinated}, while the
following paragraphs introduce notation and explain variables.

\subsection{Assumptions}

On top of the statements of the protocol setup in Section~\ref{sec:setup}, the
off-chain protocol logic relies on these assumptions:
\todo{move some/merge with protocol setup?}
\begin{itemize}
  \item Every network message received from a specific party is checked for
        authentication. An implementation of the specification needs to find a
        suitable means of (channel) authentication. Unauthenticated messages are
        dropped.
  \item The head protocol gets correctly (and with completeness) notified about
        observed transactions on-chain belonging to the respective head
        instance.
  \item The specification covers only a single instance of a Hydra head.
        However, some implementations may choose to track multiple instances. As
        multiple Hydra heads might exist on the same blockchain, it is vital
        that they do not interfere and the specification will take special care
        to ensure this.
  \item All events are processed to completion, i.e.\ run-to-completion semantics
        without preemption.
  \item Events are deduplicated. That is, any two identical events must not lead
        to multiple invocations of the handling semantics.
  \item Given the specification, events may pile up forever and implementations
        need to consider these situations (i.e.\ potential for DoS). Note that,
        from a security standpoint, these situations are identical to a
        non-collaborative peer.
  \item The lifecycle of a Hydra head on-chain does not cross (hard fork)
        protocol update boundaries. Note that these events are announced in
        advance hence it should be possible for implementations to react in such
        a way as to expedite closing of the head before such a protocol update.
        This further assumes that the contestation period parameter is picked
        accordingly.
\end{itemize}

\subsection{Notation}
\todo{missing:, apply tx, projection, map access}
\begin{itemize}
  \item $\KwOn~event$ specifies how the protocol reacts on a given $event$.
        Further information may be available from the constituents of $event$
        and origin of the event.
  \item $\Req~p$ means that boolean expression $p \in \tyBool$ must be satisfied
        for the further execution of a routine, while discontinued on $\neg p$.
  \item $\KwWait~p$ is a \todo{blocking in GDoc?} non-blocking wait for boolean
        predicate $p \in \tyBool$ to be satisfied. On $\neg p$, the execution of
        the routine is stopped, queued, and reactivated at latest when $p$ is
        satisfied.
  \item $\Multi{}~msg$ means that a message $msg$ is (channel-) authenticated
        and sent to all participants of this head, including the sender.
  \item $\PostTx{}~tx$ has a party create transaction $tx$, potentially from
        some data, and submit it on-chain. See Section~\ref{sec:on-chain} for
        individual transaction details.
  \item $\Out{}~event$ signals an observation of $event$, which is used in the
        security definition and proofs of Section~\ref{sec:security}. This
        keyword can be ignored when implementing the protocol.
\end{itemize}
\todo{fail not used anymore? do we need it?}

\subsection{Variables}

Besides parameters agreed in the protocol setup (see Section~\ref{sec:setup}), a
party's local state consists of the following variables:

\begin{itemize}
  \item $\hats$: Sequence number of latest seen snapshot.
  \item $\bars$: Sequence number of latest confirmed snapshot.
  \item $\barsigma$: Signature associated with the latest confirmed snapshot.
  \item $\hatmU$: UTxO set of the latest seen snapshot.
  \item $\barmU$: UTxO set associated with the latest confirmed snapshot.
  \item $\hatSigma \in {(\tyNatural \times \tyBytes)}^{*}$: Accumulator of signatures of the latest seen snapshot, indexed by parties.
  \item $\hatmL$: Local ledger state used to validate new and requested
        transactions against.
  \item $\mT_{all} \in {(\tyBytes \times \mT)}^{*}$: Set of all transactions,
        indexed by their transaction id, ever received via $\mathtt{reqTx}$
        (independent of their validity).\todo{needed? prune using $\hatmT$?}
  \item $\hatmT \in {(\tyBytes \times \mT)}^{*}$: Set of transactions, indexed by
        their transaction id, that extend from the last confirmed snapshot
        $\barmU$ to form $\hatmL$. These are also the transactions that would go
        into the next snapshot (if this party is the next leader).
\end{itemize}

\subsection{Protocol flow}

\todo{write about rollbacks}

\subsubsection{Initializing the head}

\dparagraph{$\hpInit$.}\quad Before a head can be initialized, all
parties need to exchange and agree on protocol parameters during the protocol
setup phase (see Section~\ref{sec:setup}), so we can assume the public Cardano
keys $\cardanoKeys^{setup}$, Hydra keys $\hydraKeysAgg^{setup}$, as well as the contestation
period $\cPer^{setup}$ are available. One of the clients then can start head initialization using the $\hpInit$ command, which will result in an $\mtxInit$ transaction being posted.\\

\dparagraph{$\mathtt{initialTx}$.}\quad All parties will receive this $\mtxInit$
transaction and validate announced parameters against the pre-agreed $setup$
parameters, as well as the structure of the transaction and the minting policy
used. This is a vital step to ensure the initialized Head is valid, which
cannot be checked completely on-chain (see also Section~\ref{sec:init-tx}). \\

\dparagraph{$\mathtt{commitTx}$.}\quad As each party $p_{j}$ posts a
$\mtxCommit$ transaction, the protocol records observed committed UTxOs of each
party $U_j$. With all committed UTxOs known, the $\eta$-state is created (as
defined in Section~\ref{sec:collect-tx}) and the $\mtxCollect$ transaction is
posted. Note that while each participant may post this transaction, only one of
them will be included in the blockchain as the mainchain ledger prevents double
spending. Should any party want to abort, they would post an $\mtxAbort$
transaction and the protocol would end at this point.\\

\dparagraph{$\mathtt{collectComTx}$.}\quad Upon observing the $\mtxCollect$
transaction, the parties compute $\Uinit \gets \bigcup_{j=1}^{n} U_j$ using
previously observed $U_j$ and initialize $\hatmU = \barmU = \hatmL = \Uinit$
with it\todo{check $\eta$ against $\Uinit$?}. The initial transaction sets are
empty $\mT = \barmT =\hatmT =\emptyset$, and $\bars = \hats = 0$.

\subsubsection{Processing transactions off-chain}

Transactions are announced and captured in so-called snapshots. Parties generate
snapshots in a strictly sequential round-robin manner. The party responsible for
issuing the $\ith i$ snapshot is the \emph{leader} of the $\ith i$ snapshot.
While the frequency of snapshots in the general Head protocol~\cite{hydrahead20}
was configurable, the Coordinated Head protocol does specify a snapshot to be
created after each transaction.\\

\dparagraph{$\hpNew$.}\quad At any time, by sending request $(\hpNew,\tx)$, a
head party can (asynchronously) submit a new transaction $\tx$ to the head
protocol. For this, the transaction must be well-formed ($\validTx$)\todo{remove
  $\validTx$?} and applicable to the current local ledger state
$\hatmL \applytx \tx \neq \bot$. If the checks
pass, a $(\hpRT,\tx)$ message is sent out to all parties.\\

\dparagraph{$\hpRT$.}\quad Upon receiving request $(\hpRT,\tx)$, the transaction gets
recorded in $\mT$ and $\barmT$ using the tx hash $tx^{\#} = \hash(tx)$ and applied to the
local \emph{seen} ledger state $\hatmL \applytx \tx$. If there is no current
snapshot ``in flight'' ($\hats = \bars$) and the receiving party $i$ is the next
snapshot leader, a message to request snapshot signatures $\hpRS$ is sent. Note
that only transaction hashes are submitted in this message. \\

\dparagraph{$\hpRS$.}\quad Upon receiving request $(\hpRS,s,\mT^{\#}_{req})$
from party $\party_j$, the receiver $\party_i$ checks that $s$ is the next
snapshot number and that party $\party_j$ is responsible for leading its
creation.\todo{define $\hpLdr$?} Party $\party_i$ then waits until the previous
snapshot is confirmed ($\bars = \hats$) and all transactions referred by hashes
in $\mT^{\#}_{req}$ are resolvable to $\mT_{res}$. Only then, $\party_i$
increments their seen-snapshot counter $\hats$, resets the signature accumulator
$\hatSigma$, and computes the UTxO set $\hatmU$ of the new (seen) snapshot as
$\hatmU \gets \barmU \applytx \mT_{res}$. Then, $\party_i$ creates a signature
$\msSig_i$ using their signing key $\hydraSigningKey$ on a message comprised by
the $\cid$, the $\eta_{0}$ corresponding to the initial UTxO set $\Uinit$, and
the new $\eta'$ given by the new snapshot's number $\hats$ a canonically
combining $\hatmU$ (see Section~\ref{sec:close-tx} for details). The signature
is sent to \emph{all} head members via message $(\hpAS,\hats,\msSig_i)$. Note
that no UTxO sets have to be exchanged in this process as the parties all
locally compute a new snapshot by the given transaction hashes. Finally, the
pending transaction set $\hatmT$ gets pruned by the just requested transactions
$\mT_{res}$ and the
local ledger state $\hatmL$ is updated accordingly.\\

\dparagraph{$\hpAS$.}\quad Upon receiving acknowledgment $(\hpAS,s,\msSig_j)$,
all participants $\Req$ that it is from an expected snapshot (either the last
seen $\hats$ or + 1), the signature is not yet included in $\hatSigma$, and
potentially $\KwWait$ for the corresponding $\hpRS$ such that $\hats = s$. They
store the received signature in the signature accumulator $\hatSigma$. If a
signature from each party has been collected, $\party_i$ aggregates the
multisignature $\msCSig$ and $\Req$ it to be valid. \todo{detect cheating (fail)
  here?} If everything is fine, the snapshot can be considered confirmed by
updating $\bars=s$ and we also store the UTxO set in $\barmU$, as well as the
signature in $\barsigma$ for later reference. Similar to the $\hpRT$, if
$\party_i$ is the next snapshot leader and there are already transactions to
snapshot in $\hatmT$, a corresponding $\hpRS$ is distributed.

\subsubsection{Closing the head}

\dparagraph{$\hpClose$.}\quad In order to close a head, a client issues the
$\hpClose$ event which uses the latest confirmed snapshot $\barmU$ to create
\begin{itemize}
  \item the new $\eta$-state $\eta'$ from the last confirmed UTxO set and snapshot
        number, and
  \item the certifiate $\xi$ using the corresponding multi-signature.
\end{itemize}
With $\eta'$ and $\xi$, the $\mtxClose$ transaction can be constructed and
posted. See Section~\ref{sec:close-tx} for details about this transaction. \\

\dparagraph{$\mathtt{closeTx}/\mathtt{contestTx}$.}\quad When a party observes
the head getting closed or contested, the $\eta$-state extracted from the
\mtxClose{} or \mtxContest{} transaction represents the latest head status that
has been aggregated on-chain so far (by a sequence of \mtxClose{} and
\mtxContest{} transactions). If the last confirmed (off-chain) snapshot is newer
than the observed (on-chain) snapshot number $s_{c}$, an updated $\eta$-state
and certificate $\xi$ is constructed posted in a \mtxContest{} transaction (see
Section~\ref{sec:contest-tx}).

\input{fig_offchain_prot}
\todo{$\combine$ on UTxO slightly different than on commits}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
