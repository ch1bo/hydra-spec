\begin{figure*}[t!]

  \def\sfact{0.8}
  \centering
  \begin{algobox}{Coordinated Hydra Head}
    \medskip
    \begin{tabular}{c}
      % CLIENT EVENTS
      \begin{tabular}{cc}
        \adjustbox{valign=t,scale=\sfact}{
         \begin{walgo}{0.6}
          %%% INIT
          \On{$(\hpInit,\hpPuv,\hpPr,\cPer)$ from client}{ %
            $\msVKL \gets \hpPuv$ \; %
            % TODO: keys are confusing
            $\hpAK^{setup} \gets \msCombVK(\msVKL)$ \; %
            % TODO unused?
            $\msSK \gets \hpPr$ \; %
            $\cPer^{setup} \gets \cPer$ \; %

            % Always post init
            $\gcChainPost(\mtxInit,\hpAK,\hppuv,\cPer)$ \; %
          }

          % TODO: commit from client?
          % TODO: abort from client?
        \end{walgo}
        }
        &

        \adjustbox{valign=t,scale=\sfact}{
        \begin{walgo}{0.6}
          %%% NEW TX
          \On{$(\hpNew,\tx)$ from client}{%
            \Req{} $\validTx(\tx) \land \hatmL \applytx \tx \neq \bot$\;
            \Multi{} $(\hpRT,\tx)$%
          }

          \vspace{12pt}

          % CLOSE from client
          \On{$(\hpClose)$ from client}{ %
            $\xi \gets (\barmU.U, \barmU.s, \barmU.\msCSig)$ \; %
            $\gcChainPost(\mtxClose,\xi)$ \; %
          }

        \end{walgo}
          }
        % &
        
        % \adjustbox{valign=t,scale=\sfact}{
        % \begin{walgo}{0.3}
        %   \If{bla}{
        %     bla \; %
        %   }      
        % \end{walgo}} %

      \end{tabular}
      
      \\
      \multicolumn{1}{l}{\line(1,0){490}} %
      \\

      % NETWORK EVENTS
      \begin{tabular}{c@{}c}
        \adjustbox{valign=t,scale=\sfact}{
        \begin{walgo}{0.65}
          %%% REQ TX
          \On{$(\hpRT,\tx)$ from $\party_j$}{%
            \Req{} $\validTx(\tx) \land \hatmL \applytx \tx \neq \bot$ \;
            
            $\mT[\hash] \gets \tx$ % all seen txs

            $\hatmT[\hash] \gets \mT[\hash]$ % candidates for next snapshot \; %

            $\hatmL \gets \hatmL\applytx\tx$ %

            % issue snapshot?
            \If{$\hats = \bars \land \hpLdr(\bars + 1) = i$}{%
              \Multi{} $(\hpRS,\bars+1,\hatmT\hpProjH)$ \;%
            }
            
          }

          \vspace{12pt} %

          %%% REQ SN
          \On{$(\hpRS,s,T)$ from $\party_j$}{ %

            \Req{} $s = \hats + 1 \land \hpLdr(s) = j$ \; %

            \Wait{$\bars = \hats \land \barmU\applytx T \not= \bot$ % meaning reach is 'complete' for extension
            }{ %
               $\hats \gets \bars + 1$ \; %

               % TODO: update security definition to observe without output keyword
               % $\forall\tx\in\Reach^{\mT}(T)$:
               %  \Out $(\hpSeen,\tx)$ \; %

               $\hatmU \gets
               \Sno(\hats,\barmU\applytx T )$ \; %

               $\msSig_i \gets %
               \msSign(\hyPr, (\hats \| U_{0}.h) \| \hatmU.h)$ \; %
 
               \Send $(\hpAS,\hats,\msSig_i)$ %
               to $\party_j$ \; %

               % \If{$\hpLdr(\hats+1) = i$}{
                 $\hatmT :\subseteq_{\mbox{max}} \mT$ s.t. $\hatmU\applytx\hatmT\not=\bot$ \; %
                 $\hatmL \gets \hatmU\applytx\hatmT$
               % }
            }
           }
          
        \end{walgo}
        }
        &

        \adjustbox{valign=t,scale=\sfact}{
        \begin{walgo}{0.6}
          %%% ACK SN
          \On{$(\hpAS,s,\msSig_j)$ from $\party_j$}{ %

            \Req{} $s \in \{\hats,\hats+1\}$ \; % 2-round ack/confirmation
            % and $\hySignedU.\hySN = \hySN$ \; %

            \Wait{$\hats=s$
            }{ %
            
            \Req{} $\hatmU.\hpSigs[j] = \undefined$ \; %

            $\hatmU.\hpSigs[j] \gets \msSig_j$ \; %

            \If{$\forall k: \hatmU.\hpSigs[k] \neq \undefined$}{ %
              $\msCSig %
              \gets \msComb((s \| U_{0}.h) \| \hatmU.\hash, %
              \msVKL, \hatmU.\hpSigs)$ \; %
              
              \If{$\msVfy(\msCVK, (\hats \| U_{0}.h) \| \hatmU.\hash,\msCSig)$}{ %
              $\bars \gets s$ \; %
              $\hatmU.\msCSig \gets \msCSig$ \; %
              $\barmU \gets \hatmU$ \; %
              $\barmT \gets \barmT \cup \barmU.T$ \; %

              % TODO: update security definition to observe without output
              % keyword
              % $\forall \tx\in T$: \Out $(\hpConf,\tx)$ \; %

              % issue snapshot?
              \If{$\hats = \bars \land \hpLdr(\bars + 1) = i \land \hatmT \neq \emptyset$}{%
                \Multi{} $(\hpRS,\bars+1,\hatmT\hpProjH)$ \;%
              }

  
            }\Else{
             \fail
            }%
            }
           }
          }  
        \end{walgo}

          }
          
        % &
        
        % \adjustbox{valign=t,scale=\sfact}{
        % \begin{walgo}{0.3}
        %   \If{bla}{
        %     bla \; %
        %   }      
        % \end{walgo}} %

      \end{tabular}

      \\
      \multicolumn{1}{l}{\line(1,0){490}} %
      \\

      % CHAIN EVENTS
      \begin{tabular}{c c}
        \adjustbox{valign=t,scale=\sfact}{
        \begin{walgo}{0.6}
          % TODO: explain that i is our index
          \On{$(\gcChainInitial, i, \hpAK, \hppuv, \cPer)$ from chain}{ %
           \Req $\hpAK=\hpAK^{setup}$\; %
           \Req $\hppuv=\hppuv^{setup}$\; %
           \Req $\cPer=\cPer^{setup}$\; %
           % \Req $\hMT=H_{\mathsf{Merkle}}(\hppuv)$ \; %
           % TODO: which U? client would need to select it
           $\gcChainPost(\mtxCom,U_{p_i})$ \; %
          }

          \vspace{12pt}

          \On{$(\gcChainCommit, j, U)$ from chain}{ %
            % TODO: make committed U simpler to read?
            $U_{p_{j}} \gets U $

            \If{$\forall k \in [1..n]: U_{p_{k}} \neq \undefined$}{ %
              % TODO: Is Combine() producing eta or U0?
              $\eta \gets \mathsf{Combine}(U_{p_1}, \ldots, U_{p_n})$ \; %
              $\gcChainPost(\mtxCCom, \eta)$ \; %
            } %
          }

        \end{walgo}
        }
        & \adjustbox{valign=t,scale=\sfact}{
          \begin{walgo}{0.6}
          % TODO: params? \hpPuv,\hpPr
          \On{$(\gcChainCollectCom)$ from chain}{ %
            % TODO: unclear where U_p1..U_pn are from (observed so far)
            \Req{} $\forall k \in [1..n]: U_{p_{k}} \neq \undefined$ \; %
            $\hats,\bars \gets 0$ \; %
            $\Uinit \gets \bigcup_{i=1}^{n} U_{p_1}$ \; %
            % TODO: Sno undefined
            $\hatmU, \barmU \gets \Sno (0,\Uinit)$ \; %
            $\hatmL \gets \Uinit$ \; %
            $\mT, \hatmT, \barmT \gets \emptyset$ \;
          }

          \vspace{12pt} %

          \On{$(\gcChainClose, \xi) \lor (\gcChainContest, \xi)$ from chain}{ %
            $(\cdot, s', \cdot) \gets \xi$ \;
            \If{$\bars > s'$}{%
              $\xi' \gets (\barmU.U, \barmU.s, \barmU.\msCSig)$ \; %
              $\gcChainPost(\mtxContest,\xi')$ \; %
            } }
          \end{walgo}
          }

      \end{tabular}

    \end{tabular}

    \bigskip
  \end{algobox}
  
  \caption{Head-protocol machine for the \emph{coordinated head} from the perspective of party
    $\party_i$.}
  \label{fig:head_coordinated}

\end{figure*}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
